" vim: set foldmethod=marker foldlevel=0 nomodeline:
" ============================================================================
" VIMRC of grepinsight
" ============================================================================
" Neovim setup {{{
if has('nvim')
    autocmd CmdwinEnter * let b:coc_suggest_disable = 1
    " system clipboard
    " set clipboard+=unnamedplus
    
    " terminal split
    command! -nargs=* T split | terminal <args>
    command! -nargs=* VT vsplit | terminal <args>
endif

if v:version >= 802 && has('popupwin') || has('nvim')
    let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6 } }
endif
" }}}
" ============================================================================
" set - settings {{{
" ============================================================================

" Vim 8 defaults
unlet! skip_defaults_vim
autocmd FileType rst syntax off
autocmd FileType json set foldmethod=indent
silent! source $VIMRUNTIME/defaults.vim
set encoding=UTF-8
filetype plugin indent on
runtime macros/matchit.vim
set pastetoggle=<F6>
set history=1000        " enable longer command mode history
set autoread            " automatically read changed file again
set autowrite
set nocompatible        " enable modern vim features
set cursorline          " highlight current line
"set lazyredraw          " redraw only when we need to.
set regexpengine=1
set showmatch           " highlight matching [{()}]
set foldenable          " enable folding
set foldlevelstart=0    " open most folds by default
set foldmethod=indent   " fold based on indent level
set splitright          " split navigation
set hidden              " allow modified/unsaved buffers in the background.
set relativenumber              " set number
set smartcase           " if capital letter is used, then do not ignore case
set ignorecase          " If the 'ignorecase' option is on, the case of normal letters is ignored. 
set shiftwidth=4        " size of an indent
set softtabstop=4       " Indentation levels very four columns"
set tabstop=4           " size of a hard tabstop number of visual spaces per TAB
set incsearch           " search as characters are entered
set hlsearch            " highlight matches
set path+=**            " provides tab-completion for all file-related tasks
set wildmenu            " display all matching files when we tab complete
set noswapfile
set conceallevel=0
set splitbelow          " put the horizontal split below
set scrolloff=2         " Minimal number of screen lines to keep above and below the cursor.
set iskeyword+=\-       " for autocompleting a word containing '-'
set background=dark     " Setting dark mode
"set clipboard=unnamed
" }}}
" ============================================================================
" # Variables {{{
" ============================================================================

let vimrplugin_assign = 0 " Stop annoying vimRplugin reassignment
let s:darwin = has('mac')

" Define maplocalleader
nnoremap <SPACE> <Nop>
let maplocalleader=" "

" }}}
" ============================================================================
" Automatically install Vim Plug {{{
" ----------------------------------------------------------------------------
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
" }}}
" ============================================================================
" # Plugin Setup VIM_PLUGIN BLOCK {{{
" ============================================================================
call plug#begin('~/.vim/plugged')

" Colorschemes
Plug 'ajmwagar/vim-deus'
Plug 'dracula/vim', { 'as': 'dracula' }
Plug 'cormacrelf/vim-colors-github'

" Basic setup
"Plug 'tpope/vim-sensible'

" Looks / Status
" Start page
Plug 'mhinz/vim-startify'
"Plug 'flazz/vim-colorschemes'
Plug 'vim-airline/vim-airline'
Plug 'junegunn/seoul256.vim'
Plug 'ryanoasis/vim-devicons'
"Plug 'yuttie/comfortable-motion.vim'
"Plug 'ap/vim-css-color'
" Color picker

" Session Management
Plug 'tpope/vim-obsession'
Plug 'airblade/vim-rooter'

" Buffer Management
Plug 'vim-scripts/BufOnly.vim'

" Files related
"Plug 'scrooloose/nerdtree'
Plug 'Shougo/junkfile.vim'
Plug 'justinmk/vim-dirvish'
Plug 'tpope/vim-vinegar'
Plug 'francoiscabrol/ranger.vim'
"Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'tpope/vim-eunuch'
Plug 'wincent/vcs-jump'

" Search files
Plug 'grepinsight/ctrlp.vim' " my mutated version that supports vimwiki tag search
Plug 'grepinsight/fzf', { 'dir': '~/.fzf', 'do': './install --all'  }
Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-peekaboo'
Plug 'mileszs/ack.vim'
Plug 'google/vim-searchindex'
Plug 'bronson/vim-visual-star-search'

"Plug 'mhinz/vim-grepper'
let g:grepper = {}
runtime autoload/grepper.vim
let g:grepper.tools = ['rg', 'git', 'ag']
let g:grepper.jump = 1
let g:grepper.stop = 500
noremap <leader>gr :GrepperRg<Space>

" Navigation
Plug 'Lokaltog/vim-easymotion'
Plug 'justinmk/vim-sneak'
"Plug 'vim-scripts/taglist.vim'
"Plug 'majutsushi/tagbar'
Plug 'liuchengxu/vista.vim'
Plug 'tpope/vim-projectionist'
Plug 'tpope/vim-unimpaired'
Plug 'christoomey/vim-tmux-navigator'
Plug 'tmhedberg/SimpylFold'
"Plug 'MattesGroeger/vim-bookmarks'

" Editing
Plug 'tpope/vim-surround'              " surround text objects with whatever
Plug 'junegunn/vim-easy-align'         " perform alignment easier
Plug 'tommcdo/vim-exchange'            " swap two text objects
Plug 'michaeljsmith/vim-indent-object' " text object
Plug 'AndrewRadev/splitjoin.vim'
Plug 'tpope/vim-repeat'
Plug 'terryma/vim-multiple-cursors'
Plug 'junegunn/vim-after-object'
Plug 'sjl/gundo.vim'
Plug 'tpope/vim-commentary'
"Plug 'jiangmiao/auto-pairs'
Plug 'Yggdroot/indentLine'
"Plug 'bronson/vim-trailing-whitespace'
Plug 'dhruvasagar/vim-table-mode'
Plug 'elzr/vim-json'
Plug 'Konfekt/FastFold'
Plug 'kalekundert/vim-coiled-snake'
"Plug 'wellle/context.vim'

" Git
Plug 'airblade/vim-gitgutter'
Plug 'kshenoy/vim-signature'
"Plug 'mhinz/vim-signify'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-rhubarb'
Plug 'fcpg/vim-osc52'
Plug 'jreybert/vimagit'
Plug 'junegunn/gv.vim'
Plug 'junegunn/vim-github-dashboard'
Plug 'mattn/gist-vim'
Plug 'mattn/webapi-vim'

" Testing
Plug 'metakirby5/codi.vim'
Plug 'janko-m/vim-test'
Plug 'tpope/vim-dispatch'

" Rlang
Plug 'ncm2/ncm2'
Plug 'roxma/nvim-yarp'
Plug 'jalvesaq/Nvim-R'
Plug 'gaalcaras/ncm-R'
Plug 'ncm2/ncm2-bufword'
Plug 'ncm2/ncm2-path'


Plug 'jalvesaq/vimcmdline'                             " sort of like slim

Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'rust-lang/rust.vim'
Plug 'fatih/vim-go'
Plug 'kana/vim-textobj-user'
Plug 'davidhalter/jedi-vim'                            " python intellisense
Plug 'jeetsukumaran/vim-pythonsense'                   " text object for python
Plug 'vim-pandoc/vim-pandoc'
Plug 'vim-pandoc/vim-pandoc-syntax'

" Lint
"Plug 'w0rp/ale'

" Completions and snippets
" if v:version >= 800
"     try
"         Plug 'Valloric/YouCompleteMe'
"     catch
"     endtry
" endif
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'ervandew/supertab'
Plug 'grepinsight/mysnippets'

" Writing
Plug 'christoomey/vim-titlecase'
"let g:titlecase_map_keys = 0
Plug 'plasticboy/vim-markdown'
Plug 'coachshea/vim-textobj-markdown'
Plug 'masukomi/vim-markdown-folding'
Plug 'tpope/vim-abolish'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
Plug 'ron89/thesaurus_query.vim' "thesaurus
"Plug 'beloglazov/vim-online-thesaurus'
Plug 'vimwiki/vimwiki'
Plug 'mattn/calendar-vim'
Plug 'jceb/vim-orgmode'
Plug 'tpope/vim-speeddating'
Plug 'vim-scripts/utl.vim'
Plug 'vim-scripts/SyntaxRange'
Plug 'lervag/vimtex'
Plug 'reedes/vim-wordy'
Plug 'AndrewRadev/switch.vim'

" Interactive coding
Plug 'jpalardy/vim-slime'

" Reading
"Plug 'JamshedVesuna/vim-markdown-preview'
Plug 'roman/golden-ratio'

" Misc
"Plug 'wincent/terminus'  " Make terminal and vim play nicely. Supports auto change
Plug 'dhruvasagar/vim-zoom'
Plug 'tomtom/tlib_vim'
Plug 'itchyny/calendar.vim'
Plug 'sgur/vim-editorconfig'
Plug 'chrisbra/csv.vim'
Plug 'liuchengxu/vim-which-key'
Plug 'machakann/vim-highlightedyank'


" Syntax Highlighting / FileType
Plug 'maverickg/stan.vim'
Plug 'Glench/Vim-Jinja2-Syntax'
Plug 'ibab/vim-snakemake'
Plug 'broadinstitute/vim-wdl'

if executable('black')
    Plug 'psf/black', { 'on':  'Black' }
endif


" Profiling
Plug 'tweekmonster/startuptime.vim'

" Deprecated
" Plug 'autozimu/LanguageClient-neovim', {
"     \ 'branch': 'next',
"     \ 'do': 'bash install.sh',
"     \ }
" Plug 'szw/vim-g'
" Plug 'mattn/emmet-vim'
" Plug 'DougBeney/pickachu'
" Plug 'luochen1990/rainbow'  " parenthesis colors

call plug#end()

set t_Co=256


if has('termguicolors')
    set termguicolors
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif

let g:deus_termcolors=256


" }}}
" ============================================================================
" # Productivity Aliases {{{
" ============================================================================
" never ring a bell {{{
if exists('&belloff')
    set belloff=all
endif
" }}}

" First line

" 3rd line
function! ToggleQuickFix()
  if exists("g:qwindow")
    lclose
    unlet g:qwindow
  else
    try
      lopen 10
      let g:qwindow = 1
    catch 
      echo "No Errors found!"
    endtry
  endif
endfunction


" Switch between the last two files

" ----------------------------------------------------------------------------
" R assignment {{{
" execute "set <M-->=\033-"
" execute "set <M-m>=\033m"
inoremap <M--> <-
inoremap <M-m> %>%
command! MakeTags !ctags -R .
" }}}
" ----------------------------------------------------------------------------
nnoremap <Leader>vv :e $HOME/.dotfiles/vim/vim.cheatsheet.md<CR>

"insert file name : \fn in insert mode
inoremap \fn <C-R>=expand("%:t")<CR>
inoremap <Leader>fn <C-R>=expand("%:t")<CR>

"focus current fold
nnoremap zs zMzvzz
nnoremap <Leader>fmi :set foldmethod=indent<CR>
nnoremap <Leader>fms :set foldmethod=syntax<CR>
nnoremap <Leader>fmm :set foldmethod=marker<CR>
nnoremap <Leader>fme :set foldmethod=expr<CR>

" Make movement more visual oriented
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk


nnoremap <leader>ln :Lines<CR>
nmap \q :nohlsearch<CR>
"nmap <leader>e :NERDTreeToggle<CR>
nmap <leader>e :Dirvish<CR>

" Use sane regexes.
nnoremap / /\v
vnoremap / /\v


"Keep search matches in the middle of the window and pulse the line when moving to them
nnoremap n nzzzv
nnoremap N Nzzzv
nnoremap vv ^vg_

" Make execute able
nnoremap <Leader>x :!chmod 750 %<CR>
command! ReadOnlyfy execute "normal! \<esc>:!chmod 440 %<CR>"

" space open/closes folds
nnoremap <space> za

" highlight last inserted text
nnoremap gV `[v`]

" Editing source files
nnoremap <Leader>ev :e $HOME/.dotfiles/vim/vimrc<CR>
nnoremap <Leader>sv :source $MYVIMRC<CR>
nnoremap <Leader>es :vsplit ~/.vim/plugged/mysnippets/UltiSnips<CR>
"reselect after indenting
vnoremap < <gv
vnoremap > >gv
"never use Ex mode -- I never *mean* to press it
nnoremap Q <ESC>
"Escape Mode
imap jj <Esc>
"never use F1 -- I'm reaching for escape
noremap  <F1> <ESC>
noremap! <F1> <ESC>
lnoremap <F1> <ESC>
nnoremap aa pkj


nnoremap <Leader>c :ccl<CR>
nnoremap <Leader>di :sp ~/Dropbox/vimwiki/diary/<C-R>=strftime("%Y-%m-%d")<CR>.md<CR>
command! Today execute "normal! \<esc>:e ~/Dropbox/vimwiki/diary/\<C-R>=strftime(\"%Y-%m-%d\")\<CR>.md\<CR>"
command! Kanban execute "normal! \<esc>:e ~/Dropbox/vimwiki/kanban.md\<CR>"
command! Month execute "normal! \<esc>:e ~/Dropbox/vimwiki/diary/\<C-R>=strftime(\"%Y-%m\")\<CR>.md\<CR>"
command! Week execute "normal! \<esc>:e ~/Dropbox/vimwiki/diary/\<C-R>=strftime(\"%Y-week%V\")\<CR>.md\<CR>"
command! Year execute "normal! \<esc>:e ~/Dropbox/vimwiki/diary/\<C-R>=strftime(\"%Y\")\<CR>.md\<CR>"
command! Meeting execute "normal! \<esc>:sp ~/Dropbox/vimwiki/meeting--\<C-R>=strftime(\"%Y-%m-%d\")\<CR>.md\<CR>"

" Buffers 
" close buffer
function! BufferSmartDelete()
	let num_buf = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))

	if num_buf == 1
		bd
		return
	endif
	let diffbufnr = bufnr('^fugitive:')
    if diffbufnr > -1 && &diff
        diffoff | q
        if bufnr('%') == diffbufnr
            Gedit
        endif
        setlocal nocursorbind
        return
    endif

	bp
	bd #
	if winnr() == 2
		q
	endif
endfunction

command! BufferSmartDelete :call BufferSmartDelete()
nnoremap BB :call BufferSmartDelete()<CR>
nnoremap QQ :q<CR>

" reopen the closed buffer
nnoremap <c-s-t> :b#<CR>:e<CR>
" 

" Bash alias shortcut 
nnoremap <Leader>bas :e $HOME/.dotfiles/bash/share/bash_aliases_share<CR>
nnoremap <Leader>bcs :e $HOME/.dotfiles/bash/share/bash_colors_share<CR>
nnoremap <Leader>bfs :e $HOME/.dotfiles/bash/share/bash_functions_share<CR>
nnoremap <Leader>bss :e $HOME/.dotfiles/bash/share/bash_settings_share<CR>
nnoremap <Leader>bal :e $HOME/.dotfiles/bash/local/bash_aliases_local<CR>
nnoremap <Leader>bpl :e $HOME/.dotfiles/bash/local/bash_paths_local<CR>
nnoremap <Leader>bsl :e $HOME/.dotfiles/bash/local/bash_settings_local<CR>
" }}}
" ============================================================================
" PythonRelated {{{

function! ImportFix()
    ^cwfrom^[$F.r i import^[^
endfunction

" TODO run it only on python file and only if yapf is available
" setlocal equalprg=yapf

" Import fix
nnoremap <Leader>if ^cwfrom<Esc>$F.r i import<Esc>^ 


command! BlackAuto autocmd BufWritePre *.py execute ':Black'

autocmd FileType python nmap <Space> <Plug>SlimeParagraphSend
autocmd FileType python vmap <Space> <Plug>SlimeRegionSend

" }}}
" ============================================================================
" Advanced Settings --------------------------------------------------{{{
"
" ----------------------------------------------------------------------------
" Undo {{{
"
set undofile                " Save undos after file closes
set undodir=$HOME/.vim/undo " where to save undo histories
set undolevels=10000         " How many undos
set undoreload=10000        " number of lines to save for undo
" }}}

" }}}
" ============================================================================
"  Mouse Related {{{
" Allow mouse for easy resizing
" set ttymouse=xterm2
set mouse=a
" set mouse+=a
" if &term =~ '^screen'
"     " tmux knows the extended mouse mode
"     set ttymouse=xterm2
" endif
" set mouse=c
"  }}}
" ============================================================================
" Auto settings {{{
" ============================================================================
"save when losing focus
au FocusLost * :silent! wall
au FocusLost * :wa

" Make sure Vim returns to the same line when you reopen a file.
augroup line_return
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

au CursorHold * checktime


" }}}
" ============================================================================
function! MarkWindowSwap() "{{{
  let g:markedWinNum = winnr()
  endfunction

function! DoWindowSwap()
  "Mark destination
  let curNum = winnr()
  let curBuf = bufnr( "%" )
  exe g:markedWinNum . "wincmd w"
  "Switch to source and shuffle dest->source
  let markedBuf = bufnr( "%" )
  "Hide and open so that we aren't prompted and keep history
  exe 'hide buf' curBuf
  "Switch to dest and shuffle source->dest
  exe curNum . "wincmd w"
  "Hide and open so that we aren't prompted and keep history
  exe 'hide buf' markedBuf
endfunction

nmap <silent> <leader>mw :call MarkWindowSwap()<CR>
nmap <silent> <leader>pw :call DoWindowSwap()<CR>

"""""""""""""""""
" Ack motions {{{

" Motions to Ack for things.  Works with pretty much everything, including:
"
"   w, W, e, E, b, B, t*, f*, i*, a*, and custom text objects
"
" Awesome.
"
" Note: If the text covered by a motion contains a newline it won't work.  Ack
" searches line-by-line.

nnoremap <silent> <leader>A :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> <leader>A :<C-U>call <SID>AckMotion(visualmode())<CR>
xnoremap <silent> <leader>A :<C-U>call <SID>AckMotion(visualmode())<CR>
nmap <Leader>ack :Ack! "\b<cword>\b" <CR>
"nnoremap <bs> :Ack! '\b<c-r><c-w>\b'<cr>
"xnoremap <silent> <bs> :<C-U>call <SID>AckMotion(visualmode())<CR>



function! s:CopyMotionForType(type)
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction

function! s:AckMotion(type) abort
    let reg_save = @@

    call s:CopyMotionForType(a:type)

    execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

    let @@ = reg_save
endfunction

" check file change every 4 seconds ('CursorHold') and reload the buffer upon detecting change
au CursorHold * checktime


" Useful hotkeys

nnoremap <Leader>btt :bufdo tab split<CR>
nnoremap <Leader>gi :e ./.gitignore<CR>
nnoremap <Leader>hh :Helptags<CR>
nnoremap <Leader>ht :Helptags<CR>
nnoremap <Leader>ls :ls<CR>
vnoremap <Leader>tc :<C-U>silent! normal! gV:!titlecase<CR>

" Open markdown
nnoremap <Leader>md :w<CR> :!cygstart %<CR>

" <Leader>f{char} to move to {char}
map  <Leader>f <Plug>(easymotion-bd-f)
nmap <Leader>f <Plug>(easymotion-overwin-f)

" s{char}{char} to move to {char}{char}
nmap s <Plug>(easymotion-overwin-f2)

" Move to line
map <Leader>L <Plug>(easymotion-bd-jk)
nmap <Leader>L <Plug>(easymotion-overwin-line)

" Move to word
map  <Leader>w <Plug>(easymotion-bd-w)
nmap <Leader>w <Plug>(easymotion-overwin-w)
map  <Leader>w$ <Plug>(easymotion-bd-w)
nmap <Leader>w$ <Plug>(easymotion-overwin-w)

"airline support
let g:airline#extensions#tabline#enabled = 1


" crontab stuff
if $VIM_CRONTAB == "true"
    set nobackup
    set nowritebackup
endif

"Golang
let g:go_fmt_command = "goimports"

if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif

" NERDTreee
let NERDTreeIgnore = ['\.pyc$', 'db.sqlite3']
let NERDTreeChDirMode=0


" ----------------------------------------------------------------------------
" Plugin - CtrlP
" ----------------------------------------------------------------------------
let g:ctrlp_use_caching = 0
let g:ctrlp_user_command = 'fd $FD_OPTS -E "*.pdf" -E "*.Rd"'

" Tagbar
nmap <F8> :TagbarToggle<CR>

" ----------------------------------------------------------------------------
" Plugin - Fugitive
" ----------------------------------------------------------------------------
"  - blame
nnoremap <leader>b :Gblame<CR>
nnoremap <silent> <leader>gcv :Gcommit -v <CR>
nnoremap <leader>gw :Gwrite <CR>:Gcommit -v<CR>
nnoremap <leader>gf :GitGutterFold<CR>
nnoremap <leader>vd :Gvdiff<CR>
nnoremap <leader>gvd :Gvdiff<CR>
nnoremap <leader>gd :Gvdiff<CR>
nnoremap <leader>gau :Git add -u<CR><CR>

"  - diff
command! Greview :Git! diff --staged
"nnoremap <leader>r :Greview<cr>

"  - status
" Obtained from https://gist.github.com/actionshrimp/6493611
function! ToggleGStatus()
    if buflisted(bufname('.git/index'))
        bd .git/index
    else
        Gstatus
    endif
endfunction
command! ToggleGStatus :call ToggleGStatus()
nnoremap <leader>s :ToggleGStatus<CR>
nnoremap <leader>ss :ToggleGStatus<CR>
nnoremap <leader><leader>s :ToggleGStatus<CR>

" Copy and Paste : https://vi.stackexchange.com/questions/84/how-can-i-copy-text-to-the-system-clipboard-from-vim
"noremap <Leader>y "*y
noremap <Leader> y:call SendViaOSC52(getreg('"'))<cr>
noremap <Leader>Y "+y
noremap <Leader>p "*p
noremap <Leader>P "+p

" Autopair
let g:AutoPairsShortcutToggle = '<Leader>m'


" Spell file
" set spelllang=en
set spellfile=$HOME/.dotfiles/vim/spell/en.utf-8.add
" set spell
nnoremap <Leader>sp :e $HOME/.dotfiles/vim/spell/en.utf-8.add<CR>
nnoremap <Leader>ssp :mkspell! $HOME/.dotfiles/vim/spell/en.utf-8.add<CR>


" Tag for R
let g:tagbar_type_r = {
    \ 'ctagstype' : 'r',
    \ 'kinds'     : [
        \ 'f:Functions',
        \ 'g:GlobalVariables',
        \ 'v:FunctionVariables',
    \ ]
\ }

" Tag for markdown (https://github.com/majutsushi/tagbar/issues/70)
let g:tagbar_type_markdown = {
    \ 'ctagstype': 'markdown',
    \ 'ctagsbin' : '~/src/markdown2ctags/markdown2ctags.py',
    \ 'ctagsargs' : '-f - --sort=yes',
    \ 'kinds' : [
        \ 's:sections',
        \ 'i:images'
    \ ],
    \ 'sro' : '|',
    \ 'kind2scope' : {
        \ 's' : 'section',
    \ },
    \ 'sort': 0,
\ }

" let g:tagbar_type_markdown = {
"             \ 'ctagstype' : 'markdown',
"             \ 'kinds' : [
"                 \ 'h:headings',
"                 \ 'l:links',
"                 \ 'i:images'
"             \ ],
"     \ 'sort' : 0
" \ }

"colorscheme Tomorrow-Night
"
"" Set color scheme according to current time of day.
let hr = str2nr(strftime('%H'))
if hr <= 6 || hr >= 18
    let cs = 'dracula'
else
    let cs = 'seoul256-light'
endif
try
    let cs = 'dracula'
    execute 'colorscheme '.cs
catch
endtry

" github theme
" colorscheme github
" " if you use airline / lightline
" let g:airline_theme = "github"
" let g:lightline = { 'colorscheme': 'github' }

"colorscheme dracula
"colorscheme deus

" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

"=================================================================
" Plugin - Vim Test
"=================================================================
let test#python#runner = 'pytest'
"let test#python#pytest#options = '-s -v'
let test#python#pytest#options = ''

" these "Ctrl mappings" work well when Caps Lock is mapped to Ctrl
nmap <silent> t<C-n> :TestNearest<CR> " t Ctrl+n
nmap <silent> t<C-f> :TestFile<CR>    " t Ctrl+f
nmap <silent> t<C-s> :TestSuite<CR>   " t Ctrl+s
nmap <silent> t<C-l> :TestLast<CR>    " t Ctrl+l
nmap <silent> t<C-g> :TestVisit<CR>   " t Ctrl+g
let g:test#preserve_screen = 1
let test#strategy = "dispatch"


function! s:goyo_enter()
  silent !tmux set status off
  silent !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
  set noshowmode
  set noshowcmd
  set scrolloff=999
  set nospell
  set norelativenumber
  Limelight
  " ...
endfunction

function! s:goyo_leave()
  silent !tmux set status on
  silent !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
  set showmode
  set showcmd
  set scrolloff=2
  set spell
  set relativenumber
  Limelight!
  " ...
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

" Plugin - jedi-vim ----
" to play nicely with YCM
"let g:jedi#completions_enabled = 0



" }}}

" }}}
" ============================================================================
" # Plugin Specific Settings {{{
" ============================================================================

" {{{
" ----------------------------------------------------------------------------
" # Rooter
" ----------------------------------------------------------------------------

let g:rooter_silent_chdir = 1
let g:startify_change_to_dir = 0

" }}}

" {{{
" ----------------------------------------------------------------------------
" # OrgMode
" ----------------------------------------------------------------------------

let g:org_agenda_files=['~/Dropbox/vimwiki/*.org']
let g:org_todo_keywords=['TODO', 'DONE', 'MEETING', 'QUESTION']

" ----------------------------------------------------------------------------
" # coc
" ----------------------------------------------------------------------------

autocmd FileType vimwiki let b:coc_suggest_disable = 1
let g:coc_global_extensions = ['coc-emoji', 'coc-eslint', 'coc-prettier', 'coc-tsserver', 'coc-tslint', 'coc-tslint-plugin', 'coc-css', 'coc-json', 'coc-pyls', 'coc-yaml']

" Remap keys for gotos
nmap <silent> <leader>ld <Plug>(coc-definition)
nmap <silent> <F12> <Plug>(coc-definition)
nmap <silent> <leader>lt <Plug>(coc-type-definition)
nmap <silent> <leader>li <Plug>(coc-implementation)
nmap <silent> <leader>lf <Plug>(coc-references)

" coc.vim stuff


"nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Remap for rename current word
nmap <leader>rn <Plug>(coc-rename)


function! ShowDocumentation()
  if &filetype == 'vim'
    execute 'h '.expand('<cWORD>')
  else
    call CocAction('doHover')
  endif
endfunction
" Use K for show documentation in preview window
nnoremap <silent> <leader>K :call ShowDocumentation()<CR>

" Highlight symbol under cursor on CursorHold
"autocmd CursorHold * silent call CocActionAsync('highlight')
nmap gs <Plug>(coc-git-chunkinfo)

" Create mappings for function text object, requires document symbols feature of languageserver.
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)

function! CocSuggestionToggle()
    if !exists("b:coc_suggest_disable")
        let b:coc_suggest_disable = 1
        echo("Coc Suggestion Disabled!")
    elseif b:coc_suggest_disable
        let b:coc_suggest_disable = 0
        echo("Coc Suggestion Enabled!")
    else
        let b:coc_suggest_disable = 1
        echo("Coc Suggestion Disabled!")
    endif
endfunction


nnoremap yococ :call CocSuggestionToggle()<CR>

inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" ----------------------------------------------------------------------------
" Pandoc
" ----------------------------------------------------------------------------

let g:pandoc#modules#disabled = ['formatting']

" ----------------------------------------------------------------------------
" Whichkey
" ----------------------------------------------------------------------------

nnoremap <silent> <Leader> :<c-u>WhichKey  '\'<CR>
nnoremap <silent> , :<c-u>WhichKey  ','<CR>

" ----------------------------------------------------------------------------
" EasyAlign
" ----------------------------------------------------------------------------
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" ----------------------------------------------------------------------------
" Plugin - vim-sneak ----
" ----------------------------------------------------------------------------
let g:sneak#s_next = 1

" ----------------------------------------------------------------------------
" Plugin - vim-wiki ----
" ----------------------------------------------------------------------------
" Vimwiki
nnoremap ]d :VimwikiDiaryNextDay<CR>
nnoremap [d :VimwikiDiaryPrevDay<CR>
nnoremap <Leader>toc :VimwikiTOC<CR>
let g:vimwiki_list = [{'path': '~/Dropbox/vimwiki/',
                   \ 'syntax': 'markdown', 'ext': '.md'}]
let g:auto_tags = 1
let g:vimwiki_table_mappings = 0
let g:vimwiki_conceallevel = 1


autocmd FileType vimwiki let g:vim_markdown_folding_disabled = 1  " Let the vimwiki handle the folding



" ----------------------------------------------------------------------------
" Plugin - vim-surround ----
" ----------------------------------------------------------------------------
let g:surround_45 = "``` \r ```"

" ----------------------------------------------------------------------------
" Plugin - vim-go ----
" ----------------------------------------------------------------------------
let g:go_version_warning = 0
" ----------------------------------------------------------------------------
" Plugin - fzf ----
" ----------------------------------------------------------------------------

nnoremap <F3> :call fzf#run(fzf#wrap({'source': 'fd $FD_OPTS . $HOME', 'sink': 'edit'}))<CR>
inoremap <F3> :call fzf#run(fzf#wrap({'source': 'fd $FD_OPTS . $HOME', 'sink': 'edit'}))<CR>
nnoremap <F4> :call fzf#run(fzf#wrap({'source': 'fd --no-ignore $FD_OPTS .', 'sink': 'edit'}))<CR>
inoremap <F4> :call fzf#run(fzf#wrap({'source': 'fd --no-ignore $FD_OPTS .', 'sink': 'edit'}))<CR>
nnoremap <Leader>pv :call fzf#vim#gitfiles('', fzf#vim#with_preview('right'))<CR>

" ----------------------------------------------------------------------------
" Gundo
" ----------------------------------------------------------------------------
" toggle gundo
nnoremap <leader>u :GundoToggle<CR>

" python3 support
let g:gundo_prefer_python3 = 1

" ----------------------------------------------------------------------------
" vim-after-object
" ----------------------------------------------------------------------------
silent! if has_key(g:plugs, 'vim-after-object')
  autocmd VimEnter * silent! call after_object#enable('=', ':', '#', ' ', '|')
endif

" ----------------------------------------------------------------------------
" Plugin - Calendar
" ----------------------------------------------------------------------------
let g:calendar_google_calendar = 1
let g:calendar_google_task = 1

" ----------------------------------------------------------------------------
" Projectionist
" ----------------------------------------------------------------------------
nnoremap <leader>aa :A <CR>
nnoremap <leader><leader>a :A <CR>
nnoremap <leader>a :A <CR>

" ----------------------------------------------------------------------------
" Ale
" ----------------------------------------------------------------------------
nnoremap ]al :ALENext<CR>
nnoremap [al :ALEPrevious<CR>

let g:ale_linters={'python': ['mypy'], 'r': ['lintr'], 'wdl': ['wdl-linter'] }
let g:ale_fixers = {'python': ['yapf'], 'r': ['styler'], 'rmd': ['styler']}

autocmd FileType r let g:ale_fix_on_save = 1
autocmd FileType rmd let g:ale_fix_on_save = 1
let g:ale_python_mypy_options="--ignore-missing-imports"


"let g:ale_set_loclist = 0
"let g:ale_set_quickfix = 1
" let g:ale_open_list = 1
"nnoremap ]al <Plug>(ale_next)
"nnoremap ]al <Plug>(ale_previous)

" ----------------------------------------------------------------------------
" YouCompleteMe
" ----------------------------------------------------------------------------
let g:ycm_key_list_select_completion=[]
let g:ycm_key_list_previous_completion=[]
" ----------------------------------------------------------------------------
" Ultistnip
" ----------------------------------------------------------------------------

let g:UltiSnipsExpandTrigger="<S-tab>"
let g:UltiSnipsJumpForwardTrigger="<Tab>"
let g:UltiSnipsJumpBackwardTrigger="<S-Tab>"
"
"let g:UltiSnipsExpandTrigger = '<tab>'
"let g:UltiSnipsJumpForwardTrigger = '<tab>'
"let g:UltiSnipsJumpBackwardTrigger = '<s-tab>'

" " If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"
let g:UltiSnipsNoPythonWarning = 1
let g:UltiSnipsSnippetDirectories=["mysnippets"]

noremap <silent> <Leader>ult :UltiSnipsEdit<CR>
vmap <F9> :call UltiSnips#SaveLastVisualSelection()<CR>gvs
imap <F9> <C-R>=UltiSnips#ExpandSnippet()<CR>

" ----------------------------------------------------------------------------
" Wordy
" ----------------------------------------------------------------------------
noremap  <silent> <F9> :<C-u>NextWordy<cr>
xnoremap <silent> <F9> :<C-u>NextWordy<cr>
inoremap <silent> <F9> <C-o>:NextWordy<cr>

let g:wordy#ring = [
  \ 'alby',
  \ 'weak',
  \ ['being', 'passive-voice', ],
  \ 'business-jargon',
  \ 'weasel',
  \ 'puffery',
  \ ['problematic', 'redundant', ],
  \ ['colloquial', 'idiomatic', 'similies', ],
  \ 'art-jargon',
  \ ['contractions', 'opinion', 'vague-time', 'said-synonyms', ],
  \ 'adjectives',
  \ 'adverbs',
  \ ]

" ----------------------------------------------------------------------------
" Thesaurus
" ----------------------------------------------------------------------------
let g:tq_enabled_backends=["mthesaur_txt"]

" }}}
" ============================================================================
" Etc {{{
" ============================================================================
"
" If two files are loaded, switch to the alternate file, then back.
" That sets # (the alternate file).
if argc() == 2
  n
  e #
endif

function! RenameFile() "{{{
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
nnoremap <F2> :call RenameFile()<cr>

"}}}
" }}}
" ============================================================================
" Unused/Disabled {{{
"hi Comment  guifg=#80a0ff ctermfg=darkred
"
""Buffer navigation
"nnoremap <silent> [b :bprevious<CR>
"nnoremap <silent> ]b :bnext<CR>
"nnoremap <silent> [B :bfirst<CR>
"nnoremap <silent> ]B :blast<CR>
"
"Remapping marking pos
" nnoremap ' `
" nnoremap ` '

" let g:indentguides_state = 0
" function! IndentGuides() " {{{
"     if g:indentguides_state
"         let g:indentguides_state = 0
"         2match None
"     else
"         let g:indentguides_state = 1
"         execute '2match IndentGuides /\%(\_^\s*\)\@<=\%(\%'.(0*&sw+1).'v\|\%'.(1*&sw+1).'v\|\%'.(2*&sw+1).'v\|\%'.(3*&sw+1).'v\|\%'.(4*&sw+1).'v\|\%'.(5*&sw+1).'v\|\%'.(6*&sw+1).'v\|\%'.(7*&sw+1).'v\)\s/'
"     endif
" endfunction " }}}
" hi def IndentGuides guibg=#303030 ctermbg=234
" nnoremap <leader>I :call IndentGuides()<cr>
"
" }}}
" ============================================================================
" ============================================================================
" Editing Setting {{{
" ============================================================================

" * Sane Line Joins
" when joining multiple commented lines, comment symbol such as '#' will
" be removed  seamlessly.
if v:version > 703 || v:version == 703 && has('patch541')
    set formatoptions+=j
endif
""" }}}
if exists('+colorcolumn')
  " Highlight up to 255 columns (this is the current Vim max) beyond 'textwidth'
  let &l:colorcolumn='+' . join(range(0, 254), ',+')
endif
" ============================================================================
" Whitespace Decoration {{{
" View white space with special characters
"
" List Chars
set list                              " show whitespace
set listchars=nbsp:⦸                  " CIRCLED REVERSE SOLIDUS (U+29B8, UTF-8: E2 A6 B8)
set listchars+=tab:▷┅                 " WHITE RIGHT-POINTING TRIANGLE (U+25B7, UTF-8: E2 96 B7)
                                      " + BOX DRAWINGS HEAVY TRIPLE DASH HORIZONTAL (U+2505, UTF-8: E2 94 85)
set listchars+=extends:»              " RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00BB, UTF-8: C2 BB)
set listchars+=precedes:«             " LEFT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00AB, UTF-8: C2 AB)
set listchars+=trail:•                " BULLET (U+2022, UTF-8: E2 80 A2)
set nojoinspaces                      " don't autoinsert two spaces after '.', '?', '!' for join command

" }}}
" ============================================================================
" ============================================================================
" Leader Keys {{{
nnoremap <Leader>fw :FixWhitespace<CR>
" }}}
" ============================================================================
" ============================================================================
" Follow symlinks when opening a file  {{{
" Sources:
"  - https://github.com/tpope/vim-fugitive/issues/147#issuecomment-7572351
"  - http://www.reddit.com/r/vim/comments/yhsn6/is_it_possible_to_work_around_the_symlink_bug/c5w91qw
" Echoing a warning does not appear to work:
"   echohl WarningMsg | echo "Resolving symlink." | echohl None |
function! MyFollowSymlink(...)
  let fname = a:0 ? a:1 : expand('%')
  if getftype(fname) != 'link'
    return
  endif
  let resolvedfile = fnameescape(resolve(fname))
  exec 'file ' . resolvedfile
endfunction
command! FollowSymlink call MyFollowSymlink()

autocmd BufReadPost * call MyFollowSymlink(expand('<afile>'))

" }}}
" ============================================================================

" ============================================================================
" Variable Settings {{{
"
let g:slime_target = "tmux"
let g:slime_default_config = {"socket_name": get(split($TMUX, ","), 0), "target_pane": ":.2"}

let vim_markdown_preview_hotkey='<C-m>'
let vim_markdown_preview_github=1
let vim_markdown_preview_browser='Google Chrome'


let g:vim_markdown_conceal = 0 "make markdown sane

let g:vimwiki_folding='expr'
"
" Make python <> vim-slime play well together
let g:slime_python_ipython = 1

" Vimtex
let g:vimtex_view_method = 'skim'

" }}}
" ============================================================================ "

" ============================================================================ "
" Leader keys {{{
" Useful shortcuts
"
inoremap \date <C-R>=strftime("%Y-%m-%d")<CR>
inoremap \dow <C-R>=strftime("%A")<CR>
inoremap \time <C-R>=strftime("%Y-%m-%dT%H:%M:%S")<CR>
inoremap \iso <C-R>=strftime("%FT%T%z")<CR>
inoremap \todo [ ]
inoremap \td [ ]
inoremap \qtd [ ] :question:
nnoremap \nosym :e <C-R>=resolve(expand("%"))<CR>
noremap <silent> <Leader>tme :TableModeEnable<CR>
noremap <silent> <Leader>one :e $MY_ONE_ON_ONE<CR>

nnoremap <Leader>def :e $HOME/vimwiki/Definitions.wiki<CR>
nnoremap <Leader>fs :!fs<CR>
nnoremap <Leader>h1 yypVr=
nnoremap <Leader>h2 yypVr-
nnoremap <Leader>k :VimwikiToggleListItem<CR>
nnoremap <Leader>ma :make -C <C-R>=GitRootFromDir(expand('%:p:h'))<CR>
nnoremap <Leader>ml :r !make lint <CR>
nnoremap <Leader>pf :%s/<F2[23]>//g <CR>
nnoremap <Leader>rmd :!Rscript -e "setwd(Sys.getenv('PWD')); rmarkdown::render('%')" && open %:r.html <CR>
nnoremap <Leader>rtt :!clear; Rscript -e "setwd(Sys.getenv('PWD')); devtools::load_all();testthat::test_file('%')"<CR>
nnoremap <Leader>tag :!tmsu tag %
nnoremap <Leader>tts :%s/\t/    /g<CR> " tab to space
nnoremap <Leader>vf :%s/ / /g <CR>

nnoremap TT :wall<CR>: !tmux kill-pane<CR>
" }}}
" ============================================================================

" ============================================================================
" Korean {{{
nnoremap ㅏ k
nnoremap ㅓ j
nnoremap ㅑ i
nnoremap ㅐ o
nnoremap ㅒ O
nnoremap ㅇㅇ dd
" }}}
" ============================================================================

" ============================================================================
" FZF!!!  {{{
inoremap <expr> <c-x><c-k> fzf#complete('cat /usr/share/dict/words $HOME/.dotfiles/vim/spell/en.utf-8.add 2>/dev/null')
" }}}
" ============================================================================

" ============================================================================
" resize panes {{{
nnoremap <silent> <Right> :vertical resize +5<cr>
nnoremap <silent> <Left> :vertical resize -5<cr>
nnoremap <silent> <Up> :resize +5<cr>
nnoremap <silent> <Down> :resize -5<cr>
" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

" }}}
" ============================================================================

" qq to record, Q to replay
nnoremap Q @q

" ============================================================================
" tmux related {{{
" ----------------------------------------------------------------------------
function! s:tmux_send(content, dest) range
  let dest = empty(a:dest) ? input('To which pane? ') : a:dest
  let tempfile = tempname()
  call writefile(split(a:content, "\n", 1), tempfile, 'b')
  call system(printf('tmux load-buffer -b vim-tmux %s \; paste-buffer -d -b vim-tmux -t %s',
        \ shellescape(tempfile), shellescape(dest)))
  call delete(tempfile)
endfunction

function! s:tmux_map(key, dest)
  execute printf('nnoremap <silent> %s "tyy:call <SID>tmux_send(@t, "%s")<cr>', a:key, a:dest)
  execute printf('xnoremap <silent> %s "ty:call <SID>tmux_send(@t, "%s")<cr>gv', a:key, a:dest)
endfunction

call s:tmux_map('<leader>tt', '')
call s:tmux_map('<leader>th', '.left')
call s:tmux_map('<leader>tj', '.bottom')
call s:tmux_map('<leader>tk', '.top')
call s:tmux_map('<leader>tl', '.right')
call s:tmux_map('<leader>ty', '.top-left')
call s:tmux_map('<leader>to', '.top-right')
call s:tmux_map('<leader>tn', '.bottom-left')
call s:tmux_map('<leader>t.', '.bottom-right')

" }}}
" ============================================================================

" ----------------------------------------------------------------------------
" #!! | Shebang
" ----------------------------------------------------------------------------
inoreabbrev <expr> #!! "#!/usr/bin/env" . (empty(&filetype) ? '' : ' '.&filetype)


function! s:root()
  let root = systemlist('git rev-parse --show-toplevel')[0]
  if v:shell_error
    echo 'Not in git repo'
  else
    execute 'lcd' root
    echo 'Changed directory to: '.root
  endif
endfunction
command! Root call s:root()



function! s:hl()
  " echo synIDattr(synID(line('.'), col('.'), 0), 'name')
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), '/')
endfunction
command! HL call <SID>hl()
" ----------------------------------------------------------------------------
" Todo
" ----------------------------------------------------------------------------
function! s:todo() abort
  let entries = []
  for cmd in ['git grep -niI -e TODO -e FIXME -e XXX -e "\[ \]" 2> /dev/null',
            \ 'grep -rniI -e TODO -e FIXME -e XXX -e "\[ \]" * 2> /dev/null']
    let lines = split(system(cmd), '\n')
    if v:shell_error != 0 | continue | endif
    for line in lines
      let [fname, lno, text] = matchlist(line, '^\([^:]*\):\([^:]*\):\(.*\)')[1:3]
      call add(entries, { 'filename': fname, 'lnum': lno, 'text': text })
    endfor
    break
  endfor

  if !empty(entries)
    call setqflist(entries)
    copen
  endif
endfunction
command! Todo call s:todo()
nnoremap <Leader>T :call s:todo()


" ----------------------------------------------------------------------------
" <Leader>?/! | Google it / Feeling lucky
" ----------------------------------------------------------------------------
function! s:goog(pat, lucky)
  let q = '"'.substitute(a:pat, '["\n]', ' ', 'g').'"'
  let q = substitute(q, '[[:punct:] ]',
       \ '\=printf("%%%02X", char2nr(submatch(0)))', 'g')
  call system(printf('open "https://www.google.com/search?%sq=%s"',
                   \ a:lucky ? 'btnI&' : '', q))
endfunction

nnoremap <leader>? :call <SID>goog(expand("<cWORD>"), 0)<cr>
nnoremap <leader>! :call <SID>goog(expand("<cWORD>"), 1)<cr>
xnoremap <leader>? "gy:call <SID>goog(@g, 0)<cr>gv
xnoremap <leader>! "gy:call <SID>goog(@g, 1)<cr>gv

" ----------------------------------------------------------------------------
" switch.vim
" ----------------------------------------------------------------------------
let g:switch_mapping = '-'
let g:switch_custom_definitions = [
\   ['MON', 'TUE', 'WED', 'THU', 'FRI'],
\   ['TRUE', 'FALSE']
\ ]


" Automatic rename of tmux window
" if exists('$TMUX') && !exists('$NORENAME')
"     au BufEnter * if empty(&buftype) | call system('tmux rename-window '.expand('%:t:S')) | endif
"     au VimLeave * call system('tmux set-window automatic-rename on')
" endif

autocmd FileType r vnoremap af :<C-U>silent! normal! [[vt{%<CR>
autocmd FileType r omap af :normal Vaf<CR>

map <leader>C :CtrlPClearCache<cr>

command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg -g "!*.pkl" -g "!*.Rd" --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

command! -bang -nargs=* Foc
  \ call fzf#vim#grep(
  \   'rg -g "!*.pkl" --column --line-number -H --color=always --smart-case "^#" '.shellescape(expand('%')), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

command! -bang -nargs=* J
  \ call fzf#vim#grep(
  \   'rg -g "!*.pkl" --column --line-number -H --color=always --smart-case "^\`\`\`" '.shellescape(expand('%')), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)


" Zoom / Restore window.
function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        call system("tmux resize-pane -Z")
        execute t:zoom_winrestcmd
        let t:zoomed = 0
        "execute 'silent ' . '!tmux resize-pane -Z'
    else
        let t:zoom_winrestcmd = winrestcmd()
        call system("tmux resize-pane -Z")
        resize
        vertical resize
        let t:zoomed = 1
        "execute 'silent ' . '!tmux resize-pane -Z'

    endif
endfunction
command! ZoomToggle call s:ZoomToggle()

let g:tagbar_type_vimwiki = {
            \   'ctagstype':'vimwiki'
            \ , 'kinds':['h:header']
            \ , 'sro':'&&&'
            \ , 'kind2scope':{'h':'header'}
            \ , 'sort':0
            \ , 'ctagsbin':"$HOME/src/productivity/tagbar_vimwiki.py"
            \ , 'ctagsargs': 'markdown'
            \ }

let g:tagbar_type_rmd = {
          \   'ctagstype':'rmd'
          \ , 'kinds':['h:header', 'c:chunk', 'f:function', 'v:variable']
          \ , 'sro':'&&&'
          \ , 'kind2scope':{'h':'header', 'c':'chunk', 'f':'function', 'v':'variable'}
          \ , 'sort':0
          \ , 'ctagsbin':"$HOME/src/productivity/tagbar_rmarkdown.py"
          \ , 'ctagsargs':''
          \ }

let g:sneak#use_ic_scs = 1
inoremap <Leader>fix <c-g>u<Esc>[s1z=`]a<c-g>u
inoremap <Leader>sp <c-g>u<Esc>[s1z=`]a<c-g>u

nmap <Leader>ha <Plug>GitGutterStageHunk :w<CR> :e<CR>
nmap <Leader>hr <Plug>GitGutterUndoHunk
nnoremap <Leader>vpn :!anyconnect <CR>


nmap <Leader>ju <Plug>(VcsJump)


nnoremap <Leader>pyan :!~/src/pyan/pyan.py % --dot -c -e \| dot -Tpng > <C-R>=expand('%:r')<CR>.png && open <C-R>=expand('%:r')<CR>.png <CR>
nnoremap <Leader>tgf :!~/src/pyan/pyan.py % --tgf -c -e  > <C-R>=expand('%:r')<CR>.tgf<CR> 


if filereadable(expand("~/.vimrc_work"))
    source ~/.vimrc_work
endif
"UltiSnipsAddFiletypes Rmd.R
"
"

function! GitRootFromDir(myarg)
    let cmd ='cd '. a:myarg .' && '. 'git rev-parse --show-toplevel '
    let root = substitute(system(cmd), '\n', '', 'g')
    return root
endfunction


" ============================================================================
" YOT YOO {{{
nnoremap yot :if exists("g:syntax_on") <Bar>
    \   syntax off <Bar>
    \ else <Bar>
    \   syntax enable <Bar>
    \ endif <CR>

nnoremap yoo :if &conceallevel==2<Bar>
    \   set conceallevel=0<Bar>
    \ else <Bar>
    \   set conceallevel=2<Bar>
    \ endif <CR>


nnoremap yof :if &foldlevelstart==0<Bar>
    \   set foldlevel=10<Bar>
    \   set foldlevelstart=10<Bar>
    \ elseif &foldlevelstart==10<Bar>
    \   set foldlevel=0<Bar>
    \   set foldlevelstart=0<Bar>
    \ endif <CR><CR>
" }}}
" ============================================================================


" au FileWritePost * :redraw!
" au TermResponse * :redraw!
" au TextChanged * :redraw!
" au QuickFixCmdPre * :redraw!
" au QuickFixCmdPost * :redraw!


" ============================================================================
" Next fold {{{
nnoremap <silent> <leader>zj :call NextClosedFold('j')<cr>
nnoremap <silent> <leader>zk :call NextClosedFold('k')<cr>
function! NextClosedFold(dir)
    let cmd = 'norm!z' . a:dir
    let view = winsaveview()
    let [l0, l, open] = [0, view.lnum, 1]
    while l != l0 && open
        exe cmd
        let [l0, l] = [l, line('.')]
        let open = foldclosed(l) < 0
    endwhile
    if open
        call winrestview(view)
    endif
endfunction
" }}}
" ============================================================================



let g:SimpylFold_fold_import = 1

set autoindent
set copyindent

" let g:LanguageClient_serverCommands = {
"     \ 'r': ['R', '--slave', '-e', 'languageserver::run()'],
"     \ 'rmd': ['R', '--slave', '-e', 'languageserver::run()'],
"     \ }

nnoremap <Leader>rg :Rg! <C-R><C-W><CR>
"let g:signify_vcs_list = [ 'git', 'hg' ]


autocmd BufEnter *.png,*.jpg,*gif exec "!open ".expand("%") | bw
autocmd BufEnter *.pdf exec "!open -a 'PDF Expert' "."\"".expand("%")."\"" | bw

" Edit the macro quickly; "q<leader>m
nnoremap <leader>m  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>

nnoremap <Leader>mg :Magit<CR>

let g:ctrlp_working_path_mode = 0


" ============================================================================
" NVim R {{{

let R_args = ['--no-save', '--quiet']

" press -- to have Nvim-R insert the assignment operator: <-
let R_assign_map = "--"

" set a minimum source editor width
let R_min_editor_width = 80

" make sure the console is at the bottom by making it really wide
let R_rconsole_width = 1000

" show arguments for functions during omnicompletion
let R_show_args = 1

" Don't expand a dataframe to show columns by default
let R_objbr_opendf = 0

" Press the space bar to send lines and selection to R console
"nmap <Space> <Plug>RDSendParagraph


" Filetype specific
autocmd FileType r nmap <Space> :call SendParagraphToR("echo", "down")<CR>
autocmd FileType r vmap <Space> :call SendSelectionToR("echo", "stay", "normal")<CR>


" Mac iTerm: custom map control-enter to something unique. Maltese cross in this case.
autocmd FileType r nnoremap <silent> ✠ :call SendLineToR("stay")<CR><Esc><Home><Down>
autocmd FileType r nnoremap <silent> œ :call SendParagraphToR("echo", "stay")<CR>
autocmd FileType r inoremap <silent> ✠ <Esc>:call SendLineToR("stay")<CR><Esc>A<DOWN>
autocmd FileType r inoremap <silent> œ <Esc>:call SendParagraphToR("echo", "stay")<CR>A
autocmd FileType r vnoremap ✠ :call SendSelectionToR("echo", "stay", "normal")<CR>

autocmd FileType rmd nmap <Space> :call SendParagraphToR("echo", "down")<CR>
autocmd FileType rmd vmap <Space> :call SendSelectionToR("echo", "stay", "normal")<CR>
autocmd FileType rmd nnoremap <silent> ✠ :call SendLineToR("stay")<CR><Esc><Home><Down>
autocmd FileType rmd nnoremap <silent> œ :call SendParagraphToR("echo", "stay")<CR>
autocmd FileType rmd inoremap <silent> ✠ <Esc>:call SendLineToR("stay")<CR><Esc>A<DOWN>
autocmd FileType rmd inoremap <silent> œ <Esc>:call SendParagraphToR("echo", "stay")<CR>A
"autocmd FileType rmd vnoremap ✠ :call SendSelectionToR("echo", "stay", "normal")<CR>

let R_assign = 0
if has('terminal')
	tnoremap <C-k> <C-w>k
	tnoremap <C-h> <C-w>h
	tnoremap <C-l> <C-w>l
	tnoremap b] <C-w>N:TmuxNavigateUp<cr>:bnext<CR>

	" For R package development
	nnoremap <Leader>rll :RSend devtools::load_all()<CR>
	tnoremap <Leader>rll <C-w>N:RSend devtools::load_all()<CR>i
	tmap <C-j> <C-w>N:TmuxNavigateDown<cr>
	tmap <C-z> <C-w>N<C-z>
endif

" }}}
" ============================================================================
" ============================================================================
" Autocmd FileType {{{
autocmd FileType gitcommit set foldlevelstart=10 "open's all folds
autocmd FileType gitcommit set foldlevel=10 "open's all folds

autocmd FileType make set foldlevelstart=1 "open's all folds
autocmd FileType make set foldlevel=1 "open's all folds


let g:golden_ratio_autocommand = 0
autocmd FileType r let g:golden_ratio_autocommand = 0
autocmd FileType rbrowser let g:golden_ratio_autocommand = 0

" }}}
" ============================================================================


" ============================================================================
" Spanish {{{

iabbrev ma_s más
iabbrev fri_os fríos
iabbrev waht what
iabbrev que_ qué
iabbrev dejo_ dejó


" }}}j
" ============================================================================

" ============================================================================
" Custom commands {{{
command! Focus execute "normal! zMzvzz"
command! Focus2 execute "normal! zMzOzt"
" }}}
" ============================================================================


function! MoveLibrary()
    silent! let @a=''
    silent! g/^library/d A
    silent! normal gg"ap
endfunction
command! MoveLibrary :call MoveLibrary()

function! GotoJump()
  jumps
  let j = input("Please select your jump: ")
  if j != ''
    let pattern = '\v\c^\+'
    if j =~ pattern
      let j = substitute(j, pattern, '', 'g')
      execute "normal " . j . "\<c-i>"
    else
      execute "normal " . j . "\<c-o>"
    endif
  endif
endfunction

command! Jump :call GotoJump()


function! JumpToLastEdit()

    echom expand('%:p')
    let last_two_commits = systemlist("git log -n 2 --oneline -- " .  expand('%:p'))
    echom last_two_commits

    let hash1= split(last_two_commits[0], ' ' )[0]
    let hash2= split(last_two_commits[1], ' ' )[0]

    echom hash1
    echom hash2

    let cmd="VcsJump diff " . hash2 . ".." . hash1
    echom cmd

    execute cmd
endfunction
command! JumpToLastEdit :call JumpToLastEdit()

" ============================================================================
" # SortUnfold {{{

":[range]SortUnfolded[!] [i][u][r][n][x][o] [/{pattern}/]
"            Sort visible lines in [range]. Lines inside closed folds
"            are kept intact; sorting is done only on the first line
"            of the fold; the other lines inside the fold move with
"            it as a unit.
" Copyright: (C) 2012 Ingo Karkat
"   The VIM LICENSE applies to this scriptlet; see ':help copyright'.
" Inspiration:
"   http://stackoverflow.com/questions/13554191/sorting-vim-folds
function! s:ErrorMsg( text )
    let v:errmsg = a:text
    echohl ErrorMsg
    echomsg v:errmsg
    echohl None
endfunction
function! s:ExceptionMsg( exception )
    " v:exception contains what is normally in v:errmsg, but with extra
    " exception source info prepended, which we cut away.
    call s:ErrorMsg(substitute(a:exception, '^Vim\%((\a\+)\)\=:', '', ''))
endfunction
function! s:GetClosedFolds( startLnum, endLnum )
"******************************************************************************
"* PURPOSE:
"   Determine the ranges of closed folds within the passed range.
"* ASSUMPTIONS / PRECONDITIONS:
"   None.
"* EFFECTS / POSTCONDITIONS:
"   None.
"* INPUTS:
"   a:startLnum First line of the range.
"   a:endLnum   Last line of the range.
"* RETURN VALUES:
"   List of [foldStartLnum, foldEndLnum] elements.
"******************************************************************************
    let l:folds = []
    let l:lnum = a:startLnum
    while l:lnum <= a:endLnum
    let l:foldEndLnum = foldclosedend(l:lnum)
    if l:foldEndLnum == -1
        let l:lnum += 1
    else
        call add(l:folds, [l:lnum, l:foldEndLnum])
        let l:lnum = l:foldEndLnum + 1
    endif
    endwhile
    return l:folds
endfunction
function! s:Join( lnum, isKeepSpace, separator )
    if a:isKeepSpace
    let l:lineLen = len(getline(a:lnum))
    execute a:lnum . 'join!'
    if ! empty(a:separator)
        if len(getline(a:lnum)) == l:lineLen
        " The next line was completely empty.
        execute 'normal! A' . a:separator . "\<Esc>"
        else
        call cursor(a:lnum, l:lineLen + 1)
        execute 'normal! i' . a:separator . "\<Esc>"
        endif
    endif
    else
    execute a:lnum
    normal! J
    if ! empty(a:separator)
        execute 'normal! ciw' . a:separator . "\<Esc>"
    endif
    endif
endfunction
function! s:JoinFolded( isKeepSpace, startLnum, endLnum, separator )
    let l:folds = s:GetClosedFolds(a:startLnum, a:endLnum)
    if empty(l:folds)
    return [0, 0]
    endif

    let l:joinCnt = 0
    let l:save_foldenable = &foldenable
    set nofoldenable
    try
    for [l:foldStartLnum, l:foldEndLnum] in reverse(l:folds)
        let l:cnt = l:foldEndLnum - l:foldStartLnum
        for l:i in range(l:cnt)
        call s:Join(l:foldStartLnum, a:isKeepSpace, a:separator)
        endfor
        let l:joinCnt += l:cnt
    endfor
    finally
    let &foldenable = l:save_foldenable
    endtry
    return [len(l:folds), l:joinCnt]
endfunction
function! s:SortUnfolded( bang, startLnum, endLnum, sortArgs )
    let [l:foldNum, l:joinCnt] = s:JoinFolded(1, a:startLnum, a:endLnum, "\<C-V>\<C-J>")
    if empty(l:foldNum)
    call s:ErrorMsg('No folds found')
    return
    endif

    let l:reducedEndLnum = a:endLnum - l:joinCnt
    try
    execute printf('%d,%dsort%s %s', a:startLnum, l:reducedEndLnum, a:bang, a:sortArgs)
    catch /^Vim\%((\a\+)\)\=:E/
    call s:ExceptionMsg(v:exception)
    finally
    silent execute printf('%d,%dsubstitute/\%%d0/\r/g', a:startLnum, l:reducedEndLnum)
    endtry
endfunction
command! -bang -range=% -nargs=* SortUnfolded call setline(<line1>, getline(<line1>)) | call s:SortUnfolded('<bang>', <line1>, <line2>, <q-args>)



" }}}
" ============================================================================
" ============================================================================
" # Comma Leader key {{{
"

nnoremap <silent> ,c  :CocConfig<CR>
" E as in Error
nnoremap <silent> ,e  :<C-u>CocList diagnostics<cr>
" O as in Only
" Find symbol of current document
nnoremap <silent> ,o  :only<CR>

" Remap for format selected region
xmap ,f  <Plug>(coc-format-selected)
nmap ,f  <Plug>(coc-format-selected)
nmap ,q  <Plug>(coc-fix-current)
nmap ,l yor


" # Bracket Leader keys
nnoremap <silent> ]j :call NextClosedFold('j')<cr>
nnoremap <silent> [j :call NextClosedFold('k')<cr>
" if v:version >= 704
" else
" endif

" }}}
" ============================================================================
" ============================================================================
" # Dynamic Numbering {{{

" Dynamic numbering + Colorize line numbers in insert and visual modes
" From https://stackoverflow.com/a/15587011/1058663
" ------------------------------------------------
function! SetCursorLineNrColorInsert(mode)
    " Insert mode: blue
    if a:mode == "i"
        highlight CursorLineNr ctermfg=4 guifg=#268bd2
        set norelativenumber

    " Replace mode: red
    elseif a:mode == "r"
        highlight CursorLineNr ctermfg=1 guifg=#dc322f

    endif
endfunction


function! SetCursorLineNrColorVisual()
    set updatetime=0

    " Visual mode: orange
    highlight CursorLineNr cterm=none ctermfg=9 guifg=#cb4b16
    set relativenumber
endfunction


function! ResetCursorLineNrColor()
    set updatetime=4000
    highlight CursorLineNr cterm=none ctermfg=0 guifg=#073642
    set norelativenumber
endfunction


" " Toggle relative number / absolute number based on visual mode or normal mode
" vnoremap <silent> <expr> <SID>SetCursorLineNrColorVisual SetCursorLineNrColorVisual()

" " Need to set this in order to make SetCursorLineNrColorVisual work
" nnoremap <silent> <script> v :call SetCursorLineNrColorVisual()<CR>v
" nnoremap <silent> <script> V :call SetCursorLineNrColorVisual()<CR>V
" nnoremap <silent> <script> <C-v> :call SetCursorLineNrColorVisual()<CR><C-v>

" augroup CursorLineNrColorSwap
"     autocmd!
"     autocmd InsertEnter * call SetCursorLineNrColorInsert(v:insertmode)
"     autocmd InsertLeave * call ResetCursorLineNrColor()
"     autocmd CursorHold * call ResetCursorLineNrColor()
" augroup END


" }}}
" ============================================================================
"


let g:cmdline_app = {'python':  'ipython'}

let cmdline_map_send_paragraph = '<Space>'



autocmd BufNewFile *.Rmd 0r ~/src/templates/report-template.Rmd


function! ClearReg()
    let regs=split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-"', '\zs')
    for r in regs
      call setreg(r, [])
    endfor
endfunction


let g:detect_mod_reg_state = -1
function! DetectRegChangeAndUpdateMark()
    let current_small_register = getreg('"-')
    let current_mod_register = getreg('""')
    if g:detect_mod_reg_state != current_small_register || 
                \ g:detect_mod_reg_state != current_mod_register
        normal! mM
        let g:detect_mod_reg_state = current_small_register
    endif
endfunction

" Mark I at the position where the last Insert mode occured across the buffer
autocmd InsertLeave * execute 'normal! mI'

" Mark M at the position when any modification happened in the Normal or Insert mode
autocmd CursorMoved * call DetectRegChangeAndUpdateMark()
autocmd InsertLeave * execute 'normal! mM'


" Spacemacs compatible


if has('nvim')
    inoremap <D-v> <C-r>+
    nnoremap <D-v> "+p
    vnoremap <D-v> "+p
else
    autocmd TerminalOpen * if bufwinnr('') > 0 | setlocal nobuflisted | endif
endif


" Rust
let g:rustfmt_autosave = 1

" Make sure background doesn't break
set t_ut=


" vim-highlightedyank: duration
let g:highlightedyank_highlight_duration = 200

function! OpenFileTypeSetting()
    let my_ft_file = "$HOME/.config/nvim/ftplugin/" . &filetype . ".vim"
    execute ":edit ". my_ft_file
endfunction

command! OpenFileTypeSetting :call OpenFileTypeSetting()
nnoremap <Leader>ft :call OpenFileTypeSetting()<CR>

" Use bash rather than sh
if &shell == 'sh'
    set shell=bash
endif
" }}}
" ============================================================================
" Leader Key Mappings {{{

" Leader {{{

nnoremap <leader>Al :left<cr>
nnoremap <leader>Ac :center<cr>
nnoremap <leader>Ar :right<cr>
vnoremap <leader>Al :left<cr>
vnoremap <leader>Ac :center<cr>
vnoremap <leader>Ar :right<cr>
nnoremap <Leader>dot :!cat % \| dot -Tpng > <C-R>=expand('%:r')<CR>.png && open <C-R>=expand('%:r')<CR>.png<CR>


"}}}

"nnoremap <LocalLeader>c :ccl<CR>
nnoremap <LocalLeader><LocalLeader> <C-^>
nnoremap <LocalLeader>a :A <CR>
nnoremap <LocalLeader>b :Buffers<CR>
nnoremap <LocalLeader>c :call ToggleQuickFix()<CR>
nnoremap <LocalLeader>d :Gvdiff<CR>
nnoremap <LocalLeader>e :edit <C-R>=expand('%:p:h') . '/' <CR>
nnoremap <LocalLeader>fs :w<CR>
nnoremap <LocalLeader>fy :let @" = expand("%:p")<CR> <bar> :call SendViaOSC52(expand('%:p'))<cr> <bar> :echo expand('%:p')<CR> 
nnoremap <LocalLeader>g :GV<CR>
nnoremap <LocalLeader>ji :BTags<CR>
nnoremap <LocalLeader>lc :lclose<CR>
nnoremap <LocalLeader>lf :BLines<CR>
nnoremap <LocalLeader>lo :lopen<CR>
nnoremap <LocalLeader>m :Magit<CR>
nnoremap <LocalLeader>o :BufOnly<CR> <bar> :only<CR>
nnoremap <LocalLeader>pro :e ~/src/productivity/
nnoremap <LocalLeader>pt :NERDTreeToggle<CR>
nnoremap <LocalLeader>q :quit <CR>
nnoremap <LocalLeader>t :!typora "%"<CR>
nnoremap <LocalLeader>toc :VimwikiTOC<CR>
nnoremap <LocalLeader>tog :!toggl-start <C-R>=expand('<cWORD>')<CR>
nnoremap <LocalLeader>v :Vista<CR>
nnoremap <LocalLeader>w :write <CR>
nnoremap <LocalLeader>wq :wq <CR>
nnoremap <LocalLeader>ww <C-w>w
nnoremap <LocalLeader>y :Goyo 120<CR>
nnoremap <silent> <LocalLeader> :<c-u>WhichKey  '<Space>'<CR>
nnoremap <silent> <LocalLeader>p :let @" = expand("%:p")<CR> <bar> :echo expand('%:p')<CR>
nnoremap <silent> <LocalLeader>z :Focus2<CR>
noremap <LocalLeader>x :Focus<CR>
noremap <silent> <LocalLeader>ch :wincmd h<CR>:close<CR>
noremap <silent> <LocalLeader>cj :wincmd j<CR>:close<CR>
noremap <silent> <LocalLeader>ck :wincmd k<CR>:close<CR>
noremap <silent> <LocalLeader>cl :wincmd l<CR>:close<CR>

" Tertiary leaderkey
nnoremap ,c :Colors<CR>
nnoremap ,g :GV<CR>
nnoremap ,h :History<CR>
nnoremap ,m :Magit<CR>
nnoremap ,r :BTags<CR>
nnoremap ,t :term<CR>
nnoremap ,x :Focus<CR>
nnoremap ,z :Focus2<CR>

" }}}
